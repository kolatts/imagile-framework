---
phase: 03-ef-core-package
plan: 05
type: execute
wave: 4
depends_on: ["03-04"]
files_modified:
  - src/Imagile.Framework.EntityFrameworkCore/Extensions/SoftDeleteExtensions.cs
  - src/Imagile.Framework.EntityFrameworkCore/Extensions/AuditQueryExtensions.cs
  - src/Imagile.Framework.EntityFrameworkCore/Configuration/AuditConfiguration.cs
autonomous: true

must_haves:
  truths:
    - "Developer can restore soft-deleted entities using Restore() extension method"
    - "Developer can query entity change history using GetChangeHistory() extension"
    - "Developer can configure soft delete and tenant query filters via AuditConfiguration"
    - "Tenant filter wiring is optional - derived DbContexts call ConfigureTenantFilter in their OnModelCreating"
  artifacts:
    - path: "src/Imagile.Framework.EntityFrameworkCore/Extensions/SoftDeleteExtensions.cs"
      provides: "Extension methods for soft delete operations (Restore)"
      exports: ["SoftDeleteExtensions"]
      contains: "Restore"
      min_lines: 30
    - path: "src/Imagile.Framework.EntityFrameworkCore/Extensions/AuditQueryExtensions.cs"
      provides: "Extension methods for querying audit history"
      exports: ["AuditQueryExtensions"]
      contains: "GetChangeHistory"
      min_lines: 40
    - path: "src/Imagile.Framework.EntityFrameworkCore/Configuration/AuditConfiguration.cs"
      provides: "Configuration helper for audit-related model building"
      exports: ["AuditConfiguration"]
      contains: "ConfigureSoftDeleteFilter"
      min_lines: 50
  key_links:
    - from: "src/Imagile.Framework.EntityFrameworkCore/Extensions/SoftDeleteExtensions.cs"
      to: "src/Imagile.Framework.EntityFrameworkCore/Interfaces/IAuditableEntity.cs"
      via: "extension method target"
      pattern: "IAuditableEntity<TUserKey>"
    - from: "src/Imagile.Framework.EntityFrameworkCore/Extensions/AuditQueryExtensions.cs"
      to: "src/Imagile.Framework.EntityFrameworkCore/Entities/EntityChange.cs"
      via: "return type"
      pattern: "EntityChange<TUserKey>"
---

<objective>
Create extension methods and configuration helpers for the audit system.

Purpose: Provide developer-friendly APIs for common audit operations: restoring soft-deleted entities, querying change history, and configuring query filters. These utilities make the audit system easier to use without deep knowledge of the internals.

Output: Extension methods for soft delete and audit queries, plus configuration helper for query filters.

**Tenant Filter Wiring Clarification:** ConfigureTenantFilter is provided as a helper that DERIVED DbContexts call in their OnModelCreating. The base ImagileDbContext (Plan 04) handles TenantId population but NOT filtering - filtering is opt-in because it requires passing the tenant ID expression which varies by DbContext implementation.
</objective>

<execution_context>
@C:\Users\kolat\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\kolat\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ef-core-package/03-CONTEXT.md
@.planning/phases/03-ef-core-package/03-RESEARCH.md

# Prior plan summaries:
@.planning/phases/03-ef-core-package/03-01-SUMMARY.md
@.planning/phases/03-ef-core-package/03-02-SUMMARY.md
@.planning/phases/03-ef-core-package/03-03-SUMMARY.md
@.planning/phases/03-ef-core-package/03-04-SUMMARY.md

# EF Core package interfaces and entities:
@src/Imagile.Framework.EntityFrameworkCore/Interfaces/IAuditableEntity.cs
@src/Imagile.Framework.EntityFrameworkCore/Interfaces/ITenantEntity.cs
@src/Imagile.Framework.EntityFrameworkCore/Entities/EntityChange.cs
@src/Imagile.Framework.EntityFrameworkCore/DbContext/ImagileDbContext.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SoftDeleteExtensions</name>
  <files>src/Imagile.Framework.EntityFrameworkCore/Extensions/SoftDeleteExtensions.cs</files>
  <action>
Create extension methods for soft delete operations, primarily the Restore() method.

Implementation:
```csharp
using Imagile.Framework.Core.Interfaces;
using Imagile.Framework.EntityFrameworkCore.Interfaces;

namespace Imagile.Framework.EntityFrameworkCore.Extensions;

/// <summary>
/// Extension methods for working with soft-deleted entities.
/// </summary>
public static class SoftDeleteExtensions
{
    /// <summary>
    /// Restores a soft-deleted entity by clearing the IsDeleted flag and deletion metadata.
    /// </summary>
    /// <typeparam name="TEntity">The entity type implementing IAuditableEntity.</typeparam>
    /// <typeparam name="TUserKey">The type of the user identifier.</typeparam>
    /// <param name="entity">The soft-deleted entity to restore.</param>
    /// <param name="auditContext">The audit context provider for the current user.</param>
    /// <remarks>
    /// <para>
    /// This method sets IsDeleted to false and clears DeletedOn and DeletedBy.
    /// The ImagileDbContext SaveChanges override will automatically update ModifiedOn and ModifiedBy.
    /// </para>
    /// <para>
    /// Call SaveChanges after Restore() to persist the changes.
    /// </para>
    /// </remarks>
    /// <example>
    /// <code>
    /// // Restore a soft-deleted customer
    /// var deletedCustomer = await context.Customers
    ///     .IgnoreQueryFilters()  // Need this to find soft-deleted entities
    ///     .FirstOrDefaultAsync(c => c.Id == customerId);
    ///
    /// if (deletedCustomer?.IsDeleted == true)
    /// {
    ///     deletedCustomer.Restore(auditContext);
    ///     await context.SaveChangesAsync();
    /// }
    /// </code>
    /// </example>
    public static void Restore<TEntity, TUserKey>(
        this TEntity entity,
        IAuditContextProvider<TUserKey, object?> auditContext)
        where TEntity : IAuditableEntity<TUserKey>
    {
        if (!entity.IsDeleted)
        {
            throw new InvalidOperationException(
                $"Cannot restore entity of type {typeof(TEntity).Name}: entity is not soft-deleted (IsDeleted = false).");
        }

        entity.IsDeleted = false;
        entity.DeletedOn = null;
        entity.DeletedBy = default;

        // ModifiedOn and ModifiedBy will be set by ImagileDbContext.SaveChanges
    }

    /// <summary>
    /// Restores a soft-deleted entity without audit context (sets ModifiedBy to default).
    /// </summary>
    /// <typeparam name="TEntity">The entity type implementing IAuditableEntity.</typeparam>
    /// <typeparam name="TUserKey">The type of the user identifier.</typeparam>
    /// <param name="entity">The soft-deleted entity to restore.</param>
    /// <remarks>
    /// <para>
    /// Use this overload for background jobs or system processes without user context.
    /// ModifiedBy will be set to default(TUserKey) when SaveChanges is called.
    /// </para>
    /// </remarks>
    public static void Restore<TEntity, TUserKey>(this TEntity entity)
        where TEntity : IAuditableEntity<TUserKey>
    {
        if (!entity.IsDeleted)
        {
            throw new InvalidOperationException(
                $"Cannot restore entity of type {typeof(TEntity).Name}: entity is not soft-deleted (IsDeleted = false).");
        }

        entity.IsDeleted = false;
        entity.DeletedOn = null;
        entity.DeletedBy = default;
    }

    /// <summary>
    /// Soft-deletes an entity by setting the IsDeleted flag.
    /// </summary>
    /// <typeparam name="TEntity">The entity type implementing IAuditableEntity.</typeparam>
    /// <typeparam name="TUserKey">The type of the user identifier.</typeparam>
    /// <param name="entity">The entity to soft-delete.</param>
    /// <remarks>
    /// <para>
    /// This method only sets IsDeleted to true. The ImagileDbContext SaveChanges override
    /// will automatically populate DeletedOn and DeletedBy when the change is detected.
    /// </para>
    /// <para>
    /// Call SaveChanges after SoftDelete() to persist the changes.
    /// </para>
    /// </remarks>
    /// <example>
    /// <code>
    /// var customer = await context.Customers.FindAsync(customerId);
    /// if (customer is not null)
    /// {
    ///     customer.SoftDelete();
    ///     await context.SaveChangesAsync();  // DeletedOn, DeletedBy set automatically
    /// }
    /// </code>
    /// </example>
    public static void SoftDelete<TEntity, TUserKey>(this TEntity entity)
        where TEntity : IAuditableEntity<TUserKey>
    {
        if (entity.IsDeleted)
        {
            throw new InvalidOperationException(
                $"Cannot soft-delete entity of type {typeof(TEntity).Name}: entity is already soft-deleted.");
        }

        entity.IsDeleted = true;
        // DeletedOn and DeletedBy will be set by ImagileDbContext.SaveChanges
    }
}
```

Create the Extensions directory if it doesn't exist.
  </action>
  <verify>dotnet build src/Imagile.Framework.EntityFrameworkCore/Imagile.Framework.EntityFrameworkCore.csproj --no-restore</verify>
  <done>SoftDeleteExtensions exists with Restore() and SoftDelete() extension methods</done>
</task>

<task type="auto">
  <name>Task 2: Create AuditQueryExtensions</name>
  <files>src/Imagile.Framework.EntityFrameworkCore/Extensions/AuditQueryExtensions.cs</files>
  <action>
Create extension methods for querying audit history.

Implementation:
```csharp
using Imagile.Framework.EntityFrameworkCore.Entities;
using Imagile.Framework.EntityFrameworkCore.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace Imagile.Framework.EntityFrameworkCore.Extensions;

/// <summary>
/// Extension methods for querying entity change history.
/// </summary>
public static class AuditQueryExtensions
{
    /// <summary>
    /// Gets the change history for a specific entity.
    /// </summary>
    /// <typeparam name="TContext">The DbContext type.</typeparam>
    /// <typeparam name="TUserKey">The type of the user identifier.</typeparam>
    /// <param name="context">The DbContext containing EntityChanges.</param>
    /// <param name="entityName">The entity type name (e.g., "Customer").</param>
    /// <param name="itemId">The entity's primary key value.</param>
    /// <returns>An IQueryable of EntityChange records for the specified entity.</returns>
    /// <remarks>
    /// <para>
    /// Returns changes ordered by ChangedOn descending (most recent first).
    /// Include the Properties collection to see property-level changes.
    /// </para>
    /// </remarks>
    /// <example>
    /// <code>
    /// var customerHistory = await context.GetChangeHistory&lt;AppDbContext, int&gt;("Customer", customerId)
    ///     .Include(c => c.Properties)
    ///     .Take(10)
    ///     .ToListAsync();
    ///
    /// foreach (var change in customerHistory)
    /// {
    ///     Console.WriteLine($"{change.ChangedOn}: {change.Operation} by {change.ChangedBy}");
    ///     foreach (var prop in change.Properties)
    ///     {
    ///         Console.WriteLine($"  {prop.PropertyName}: {prop.OriginalValue} -> {prop.NewValue}");
    ///     }
    /// }
    /// </code>
    /// </example>
    public static IQueryable<EntityChange<TUserKey>> GetChangeHistory<TContext, TUserKey>(
        this TContext context,
        string entityName,
        int itemId)
        where TContext : DbContext
    {
        return context.Set<EntityChange<TUserKey>>()
            .Where(c => c.EntityName == entityName && c.ItemId == itemId)
            .OrderByDescending(c => c.ChangedOn);
    }

    /// <summary>
    /// Gets the change history for a specific entity instance.
    /// </summary>
    /// <typeparam name="TContext">The DbContext type.</typeparam>
    /// <typeparam name="TEntity">The entity type implementing IEntityChangeAuditable.</typeparam>
    /// <typeparam name="TUserKey">The type of the user identifier.</typeparam>
    /// <param name="context">The DbContext containing EntityChanges.</param>
    /// <param name="entity">The entity to get history for.</param>
    /// <returns>An IQueryable of EntityChange records for the specified entity.</returns>
    /// <remarks>
    /// <para>
    /// Uses the entity's type name and ItemId to query change history.
    /// Returns null if the entity has no ItemId (not yet persisted).
    /// </para>
    /// </remarks>
    /// <example>
    /// <code>
    /// var customer = await context.Customers.FindAsync(customerId);
    /// var history = context.GetChangeHistoryFor&lt;AppDbContext, Customer, int&gt;(customer);
    /// if (history is not null)
    /// {
    ///     var changes = await history.Include(c => c.Properties).ToListAsync();
    /// }
    /// </code>
    /// </example>
    public static IQueryable<EntityChange<TUserKey>>? GetChangeHistoryFor<TContext, TEntity, TUserKey>(
        this TContext context,
        TEntity entity)
        where TContext : DbContext
        where TEntity : IEntityChangeAuditable<TUserKey>
    {
        if (entity.ItemId is null) return null;

        return context.GetChangeHistory<TContext, TUserKey>(
            typeof(TEntity).Name,
            entity.ItemId.Value);
    }

    /// <summary>
    /// Gets changes grouped by transaction for a specific entity.
    /// </summary>
    /// <typeparam name="TContext">The DbContext type.</typeparam>
    /// <typeparam name="TUserKey">The type of the user identifier.</typeparam>
    /// <param name="context">The DbContext containing EntityChanges.</param>
    /// <param name="entityName">The entity type name.</param>
    /// <param name="itemId">The entity's primary key value.</param>
    /// <returns>Changes grouped by TransactionUnique.</returns>
    /// <example>
    /// <code>
    /// var groupedChanges = await context
    ///     .GetChangesByTransaction&lt;AppDbContext, int&gt;("Invoice", invoiceId)
    ///     .ToListAsync();
    ///
    /// foreach (var group in groupedChanges)
    /// {
    ///     Console.WriteLine($"Transaction {group.Key} at {group.First().ChangedOn}:");
    ///     foreach (var change in group)
    ///     {
    ///         Console.WriteLine($"  {change.EntityName}: {change.Operation}");
    ///     }
    /// }
    /// </code>
    /// </example>
    public static IQueryable<IGrouping<Guid, EntityChange<TUserKey>>> GetChangesByTransaction<TContext, TUserKey>(
        this TContext context,
        string entityName,
        int itemId)
        where TContext : DbContext
    {
        return context.Set<EntityChange<TUserKey>>()
            .Where(c => c.EntityName == entityName && c.ItemId == itemId)
            .GroupBy(c => c.TransactionUnique);
    }

    /// <summary>
    /// Gets all changes within a specific transaction.
    /// </summary>
    /// <typeparam name="TContext">The DbContext type.</typeparam>
    /// <typeparam name="TUserKey">The type of the user identifier.</typeparam>
    /// <param name="context">The DbContext containing EntityChanges.</param>
    /// <param name="transactionUnique">The transaction identifier.</param>
    /// <returns>All EntityChange records from the specified transaction.</returns>
    /// <example>
    /// <code>
    /// // Given a change, find all other changes in the same transaction
    /// var relatedChanges = await context
    ///     .GetTransactionChanges&lt;AppDbContext, int&gt;(change.TransactionUnique)
    ///     .Include(c => c.Properties)
    ///     .ToListAsync();
    /// </code>
    /// </example>
    public static IQueryable<EntityChange<TUserKey>> GetTransactionChanges<TContext, TUserKey>(
        this TContext context,
        Guid transactionUnique)
        where TContext : DbContext
    {
        return context.Set<EntityChange<TUserKey>>()
            .Where(c => c.TransactionUnique == transactionUnique)
            .OrderBy(c => c.EntityName)
            .ThenBy(c => c.ItemId);
    }

    /// <summary>
    /// Gets recent changes across all entities, optionally filtered by user.
    /// </summary>
    /// <typeparam name="TContext">The DbContext type.</typeparam>
    /// <typeparam name="TUserKey">The type of the user identifier.</typeparam>
    /// <param name="context">The DbContext containing EntityChanges.</param>
    /// <param name="changedBy">Optional user ID to filter by.</param>
    /// <param name="since">Optional start date to filter by.</param>
    /// <returns>Recent EntityChange records.</returns>
    /// <example>
    /// <code>
    /// // Get changes by a specific user in the last 24 hours
    /// var recentByUser = await context
    ///     .GetRecentChanges&lt;AppDbContext, int&gt;(userId, DateTime.UtcNow.AddDays(-1))
    ///     .Take(100)
    ///     .ToListAsync();
    /// </code>
    /// </example>
    public static IQueryable<EntityChange<TUserKey>> GetRecentChanges<TContext, TUserKey>(
        this TContext context,
        TUserKey? changedBy = default,
        DateTimeOffset? since = null)
        where TContext : DbContext
    {
        var query = context.Set<EntityChange<TUserKey>>().AsQueryable();

        if (changedBy is not null && !EqualityComparer<TUserKey>.Default.Equals(changedBy, default))
        {
            query = query.Where(c => EqualityComparer<TUserKey>.Default.Equals(c.ChangedBy, changedBy));
        }

        if (since.HasValue)
        {
            query = query.Where(c => c.ChangedOn >= since.Value);
        }

        return query.OrderByDescending(c => c.ChangedOn);
    }
}
```
  </action>
  <verify>dotnet build src/Imagile.Framework.EntityFrameworkCore/Imagile.Framework.EntityFrameworkCore.csproj --no-restore</verify>
  <done>AuditQueryExtensions exists with GetChangeHistory, GetChangeHistoryFor, GetChangesByTransaction, GetTransactionChanges, GetRecentChanges methods</done>
</task>

<task type="auto">
  <name>Task 3: Create AuditConfiguration helper</name>
  <files>src/Imagile.Framework.EntityFrameworkCore/Configuration/AuditConfiguration.cs</files>
  <action>
Create configuration helper for setting up soft delete and tenant query filters.

**Integration Pattern:** These methods are called by DERIVED DbContexts in their OnModelCreating override.
ImagileDbContext base class handles TenantId population, but filtering is opt-in because:
1. Tenant filter requires passing `() => AuditContext.TenantId` expression specific to each DbContext
2. Some apps may want custom filter logic
3. Named filters (EF Core 10.0) may be used instead for independent filter control

Implementation:
```csharp
using System.Linq.Expressions;
using Imagile.Framework.Core.Interfaces;
using Imagile.Framework.EntityFrameworkCore.Interfaces;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata;

namespace Imagile.Framework.EntityFrameworkCore.Configuration;

/// <summary>
/// Helper class for configuring audit-related model building options.
/// </summary>
public static class AuditConfiguration
{
    /// <summary>
    /// Configures soft delete query filters for all entities implementing IAuditableEntity.
    /// </summary>
    /// <typeparam name="TUserKey">The type of the user identifier.</typeparam>
    /// <param name="modelBuilder">The model builder.</param>
    /// <remarks>
    /// <para>
    /// Adds a global query filter that excludes entities where IsDeleted = true.
    /// Use IgnoreQueryFilters() to see soft-deleted entities.
    /// </para>
    /// <para>
    /// Call this in your DbContext's OnModelCreating method.
    /// </para>
    /// </remarks>
    /// <example>
    /// <code>
    /// protected override void OnModelCreating(ModelBuilder modelBuilder)
    /// {
    ///     base.OnModelCreating(modelBuilder);
    ///     AuditConfiguration.ConfigureSoftDeleteFilter&lt;int&gt;(modelBuilder);
    /// }
    /// </code>
    /// </example>
    public static void ConfigureSoftDeleteFilter<TUserKey>(ModelBuilder modelBuilder)
    {
        foreach (var entityType in modelBuilder.Model.GetEntityTypes())
        {
            if (ImplementsInterface(entityType.ClrType, typeof(IAuditableEntity<>)))
            {
                ConfigureSoftDeleteFilterForEntity(modelBuilder, entityType);
            }
        }
    }

    /// <summary>
    /// Configures tenant query filters for all entities implementing ITenantEntity.
    /// </summary>
    /// <typeparam name="TTenantKey">The type of the tenant identifier.</typeparam>
    /// <param name="modelBuilder">The model builder.</param>
    /// <param name="auditContextProvider">The audit context provider (must be field/property accessible at query time).</param>
    /// <remarks>
    /// <para>
    /// Adds a global query filter that restricts entities to the current tenant.
    /// Use IgnoreQueryFilters() to see entities from all tenants (with caution for security).
    /// </para>
    /// <para>
    /// <strong>Important:</strong> The auditContextProvider must be a field or property
    /// on the DbContext that EF Core can evaluate at query time.
    /// </para>
    /// </remarks>
    /// <example>
    /// <code>
    /// // In your DbContext:
    /// private readonly IAuditContextProvider&lt;int, int&gt; _auditContext;
    ///
    /// protected override void OnModelCreating(ModelBuilder modelBuilder)
    /// {
    ///     base.OnModelCreating(modelBuilder);
    ///     AuditConfiguration.ConfigureTenantFilter&lt;int&gt;(modelBuilder, () => _auditContext.TenantId);
    /// }
    /// </code>
    /// </example>
    public static void ConfigureTenantFilter<TTenantKey>(
        ModelBuilder modelBuilder,
        Expression<Func<TTenantKey?>> getCurrentTenantId)
    {
        foreach (var entityType in modelBuilder.Model.GetEntityTypes())
        {
            if (ImplementsInterface(entityType.ClrType, typeof(ITenantEntity<>)))
            {
                ConfigureTenantFilterForEntity(modelBuilder, entityType, getCurrentTenantId);
            }
        }
    }

    /// <summary>
    /// Configures both soft delete and tenant filters for all applicable entities.
    /// </summary>
    /// <typeparam name="TUserKey">The type of the user identifier.</typeparam>
    /// <typeparam name="TTenantKey">The type of the tenant identifier.</typeparam>
    /// <param name="modelBuilder">The model builder.</param>
    /// <param name="getCurrentTenantId">Expression to get the current tenant ID.</param>
    /// <remarks>
    /// <para>
    /// Convenience method that applies both filters. Entities implementing both interfaces
    /// will have both filters applied (AND logic).
    /// </para>
    /// </remarks>
    public static void ConfigureAllFilters<TUserKey, TTenantKey>(
        ModelBuilder modelBuilder,
        Expression<Func<TTenantKey?>> getCurrentTenantId)
    {
        ConfigureSoftDeleteFilter<TUserKey>(modelBuilder);
        ConfigureTenantFilter(modelBuilder, getCurrentTenantId);
    }

    /// <summary>
    /// Sets a default precision for all DateTimeOffset columns in the model.
    /// </summary>
    /// <param name="modelBuilder">The model builder.</param>
    /// <param name="precision">The precision (0-7, where 0 = seconds, 7 = 100 nanoseconds).</param>
    /// <remarks>
    /// <para>
    /// Use this to ensure consistent timestamp precision across all audit columns.
    /// Arcoro.One uses precision 0 (second-level) for performance.
    /// </para>
    /// </remarks>
    /// <example>
    /// <code>
    /// protected override void OnModelCreating(ModelBuilder modelBuilder)
    /// {
    ///     AuditConfiguration.SetDateTimeOffsetPrecision(modelBuilder, 0);
    /// }
    /// </code>
    /// </example>
    public static void SetDateTimeOffsetPrecision(ModelBuilder modelBuilder, int precision)
    {
        if (precision < 0 || precision > 7)
        {
            throw new ArgumentOutOfRangeException(nameof(precision), "Precision must be between 0 and 7.");
        }

        foreach (var entityType in modelBuilder.Model.GetEntityTypes())
        {
            foreach (var property in entityType.GetProperties()
                .Where(p => p.ClrType == typeof(DateTimeOffset) || p.ClrType == typeof(DateTimeOffset?)))
            {
                property.SetPrecision(precision);
            }
        }
    }

    private static bool ImplementsInterface(Type type, Type interfaceType)
    {
        return type.GetInterfaces()
            .Any(i => i.IsGenericType && i.GetGenericTypeDefinition() == interfaceType);
    }

    private static void ConfigureSoftDeleteFilterForEntity(ModelBuilder modelBuilder, IMutableEntityType entityType)
    {
        var clrType = entityType.ClrType;
        var parameter = Expression.Parameter(clrType, "e");

        // Get IsDeleted property
        var isDeletedProperty = clrType.GetProperty(nameof(IAuditableEntity<object>.IsDeleted));
        if (isDeletedProperty is null) return;

        var propertyAccess = Expression.Property(parameter, isDeletedProperty);
        var notDeleted = Expression.Not(propertyAccess);
        var lambda = Expression.Lambda(notDeleted, parameter);

        modelBuilder.Entity(clrType).HasQueryFilter(lambda);
    }

    private static void ConfigureTenantFilterForEntity<TTenantKey>(
        ModelBuilder modelBuilder,
        IMutableEntityType entityType,
        Expression<Func<TTenantKey?>> getCurrentTenantId)
    {
        var clrType = entityType.ClrType;
        var parameter = Expression.Parameter(clrType, "e");

        // Get TenantId property
        var tenantIdProperty = clrType.GetProperty(nameof(ITenantEntity<TTenantKey>.TenantId));
        if (tenantIdProperty is null) return;

        var propertyAccess = Expression.Property(parameter, tenantIdProperty);
        var currentTenantId = Expression.Invoke(getCurrentTenantId);
        var equality = Expression.Equal(propertyAccess, currentTenantId);
        var lambda = Expression.Lambda(equality, parameter);

        modelBuilder.Entity(clrType).HasQueryFilter(lambda);
    }
}
```

Create the Configuration directory if it doesn't exist.
  </action>
  <verify>dotnet build src/Imagile.Framework.EntityFrameworkCore/Imagile.Framework.EntityFrameworkCore.csproj --no-restore</verify>
  <done>AuditConfiguration exists with ConfigureSoftDeleteFilter, ConfigureTenantFilter, ConfigureAllFilters, and SetDateTimeOffsetPrecision methods</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `dotnet build Imagile.Framework.sln --no-restore` succeeds with no errors
- [ ] SoftDeleteExtensions has Restore() and SoftDelete() methods
- [ ] AuditQueryExtensions has GetChangeHistory and related query methods
- [ ] AuditConfiguration has ConfigureSoftDeleteFilter and ConfigureTenantFilter methods
- [ ] SetDateTimeOffsetPrecision allows configuring timestamp precision
- [ ] All methods have comprehensive XML documentation with examples
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Extension methods are intuitive and well-documented
- Configuration helper simplifies query filter setup
- DateTimeOffset precision configurable (matching Arcoro.One pattern)
</success_criteria>

<output>
After completion, create `.planning/phases/03-ef-core-package/03-05-SUMMARY.md`
</output>

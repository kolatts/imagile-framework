---
phase: 03-ef-core-package
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Imagile.Framework.Core/Interfaces/IAuditContextProvider.cs
  - src/Imagile.Framework.EntityFrameworkCore/Interfaces/ITimestampedEntity.cs
  - src/Imagile.Framework.EntityFrameworkCore/Interfaces/IAuditableEntity.cs
  - src/Imagile.Framework.EntityFrameworkCore/Interfaces/IEntityChangeAuditable.cs
  - src/Imagile.Framework.EntityFrameworkCore/Interfaces/ITenantEntity.cs
autonomous: true

must_haves:
  truths:
    - "Developer can implement ITimestampedEntity for automatic CreatedOn/ModifiedOn tracking"
    - "Developer can implement IAuditableEntity for full audit trail including soft delete"
    - "Developer can implement IEntityChangeAuditable for property-level change tracking (requires [Auditable] attribute on properties)"
    - "Developer can implement ITenantEntity independently for multi-tenant isolation"
    - "IAuditContextProvider abstraction allows injecting user/tenant context"
    - "Audit metadata uses explicit interface properties (not shadow properties) for testability and discoverability"
  artifacts:
    - path: "src/Imagile.Framework.Core/Interfaces/IAuditContextProvider.cs"
      provides: "Abstraction for audit context (user ID, tenant ID, correlation ID)"
      exports: ["IAuditContextProvider"]
      min_lines: 15
    - path: "src/Imagile.Framework.EntityFrameworkCore/Interfaces/ITimestampedEntity.cs"
      provides: "Base audit interface with CreatedOn, ModifiedOn"
      exports: ["ITimestampedEntity"]
      min_lines: 10
    - path: "src/Imagile.Framework.EntityFrameworkCore/Interfaces/IAuditableEntity.cs"
      provides: "Full audit interface with user tracking and soft delete"
      exports: ["IAuditableEntity"]
      contains: "ITimestampedEntity"
      min_lines: 20
    - path: "src/Imagile.Framework.EntityFrameworkCore/Interfaces/IEntityChangeAuditable.cs"
      provides: "Property-level change tracking interface"
      exports: ["IEntityChangeAuditable"]
      contains: "IAuditableEntity"
      min_lines: 15
    - path: "src/Imagile.Framework.EntityFrameworkCore/Interfaces/ITenantEntity.cs"
      provides: "Multi-tenant entity interface"
      exports: ["ITenantEntity"]
      min_lines: 10
  key_links:
    - from: "src/Imagile.Framework.EntityFrameworkCore/Interfaces/IAuditableEntity.cs"
      to: "src/Imagile.Framework.EntityFrameworkCore/Interfaces/ITimestampedEntity.cs"
      via: "interface inheritance"
      pattern: ": ITimestampedEntity"
    - from: "src/Imagile.Framework.EntityFrameworkCore/Interfaces/IEntityChangeAuditable.cs"
      to: "src/Imagile.Framework.EntityFrameworkCore/Interfaces/IAuditableEntity.cs"
      via: "interface inheritance"
      pattern: ": IAuditableEntity"
---

<objective>
Create the foundational interfaces for the EF Core audit logging system.

Purpose: Establish the contract-based design that allows entities to opt-in to different levels of audit tracking. The interface hierarchy enables progressive complexity - simple timestamps, full audit trail, or property-level change tracking.

Output: Five interfaces defining the audit system contracts plus the context provider abstraction in Core.

**Design Decision (EF-08 clarification):** Uses explicit interface properties for audit metadata (CreatedOn, ModifiedBy, etc.) rather than shadow properties. This intentional choice provides better testability, discoverability, and aligns with Arcoro.One production patterns (see 03-RESEARCH.md).

**Entity Opt-in (EF-07 clarification):** Entity-level opt-in is via interface implementation (ITimestampedEntity, IAuditableEntity, IEntityChangeAuditable). Property-level change tracking opt-in is via [Auditable] attribute (Plan 02).
</objective>

<execution_context>
@C:\Users\kolat\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\kolat\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ef-core-package/03-CONTEXT.md
@.planning/phases/03-ef-core-package/03-RESEARCH.md

# Core package structure for reference:
@src/Imagile.Framework.Core/Imagile.Framework.Core.csproj
@src/Imagile.Framework.Core/Attributes/AssociatedAttribute.cs

# EF Core package for reference:
@src/Imagile.Framework.EntityFrameworkCore/Imagile.Framework.EntityFrameworkCore.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IAuditContextProvider in Core package</name>
  <files>src/Imagile.Framework.Core/Interfaces/IAuditContextProvider.cs</files>
  <action>
Create the audit context provider interface in the Core package (zero dependencies).

This interface abstracts the current user/tenant context for audit logging. It goes in Core because:
1. Core has zero dependencies - this is a pure abstraction
2. Both EF Core and Blazor packages may need to provide implementations
3. Allows testing by mocking the context provider

Implementation:
```csharp
namespace Imagile.Framework.Core.Interfaces;

/// <summary>
/// Provides the current user and tenant context for audit logging operations.
/// </summary>
/// <typeparam name="TUserKey">The type of the user identifier (e.g., int, Guid, string)</typeparam>
/// <typeparam name="TTenantKey">The type of the tenant identifier (e.g., int, Guid, string)</typeparam>
/// <remarks>
/// <para>
/// Implement this interface to provide audit context from your authentication system.
/// The EF Core audit interceptor uses this to populate CreatedBy, ModifiedBy, and DeletedBy fields.
/// </para>
/// <para>
/// In ASP.NET Core, typically implemented using IHttpContextAccessor to extract claims from the current user.
/// For background services, implement with explicit user/tenant context passed at job creation.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// public class HttpContextAuditProvider : IAuditContextProvider&lt;int, int&gt;
/// {
///     private readonly IHttpContextAccessor _httpContext;
///
///     public int? UserId => _httpContext.HttpContext?.User.GetUserId();
///     public int? TenantId => _httpContext.HttpContext?.User.GetTenantId();
///     public Guid? CorrelationId => Guid.TryParse(
///         _httpContext.HttpContext?.TraceIdentifier, out var id) ? id : null;
///     public bool IsAuthenticated => UserId.HasValue;
/// }
/// </code>
/// </example>
public interface IAuditContextProvider<TUserKey, TTenantKey>
{
    /// <summary>
    /// Gets the current user's identifier, or null if not authenticated.
    /// </summary>
    TUserKey? UserId { get; }

    /// <summary>
    /// Gets the current tenant's identifier, or null if not in a tenant context.
    /// </summary>
    TTenantKey? TenantId { get; }

    /// <summary>
    /// Gets a correlation identifier for grouping related operations across services.
    /// </summary>
    /// <remarks>
    /// Use this to correlate audit records with distributed tracing.
    /// In ASP.NET Core, this is typically the HttpContext.TraceIdentifier.
    /// </remarks>
    Guid? CorrelationId { get; }

    /// <summary>
    /// Gets a value indicating whether the current context has a valid authenticated user.
    /// </summary>
    /// <remarks>
    /// Returns true when UserId has a value. Some operations (like system jobs) may
    /// have a TenantId but no UserId - check this property to determine if user-level
    /// audit fields should be populated.
    /// </remarks>
    bool IsAuthenticated { get; }
}
```

Create the Interfaces directory if it doesn't exist.
  </action>
  <verify>dotnet build src/Imagile.Framework.Core/Imagile.Framework.Core.csproj --no-restore</verify>
  <done>IAuditContextProvider interface exists with TUserKey/TTenantKey generic parameters, UserId, TenantId, CorrelationId, and IsAuthenticated members</done>
</task>

<task type="auto">
  <name>Task 2: Create ITimestampedEntity interface</name>
  <files>src/Imagile.Framework.EntityFrameworkCore/Interfaces/ITimestampedEntity.cs</files>
  <action>
Create the base timestamp interface - the simplest audit level.

Implementation:
```csharp
namespace Imagile.Framework.EntityFrameworkCore.Interfaces;

/// <summary>
/// Marks an entity for automatic timestamp tracking. Provides the most basic audit capability.
/// </summary>
/// <remarks>
/// <para>
/// Entities implementing this interface will have CreatedOn automatically set on insert
/// and ModifiedOn automatically updated on every save via the ImagileDbContext SaveChanges override.
/// </para>
/// <para>
/// Use DateTimeOffset instead of DateTime for proper timezone handling in distributed systems.
/// The timestamps are always stored in UTC.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// public class BlogPost : ITimestampedEntity
/// {
///     public int Id { get; set; }
///     public string Title { get; set; } = string.Empty;
///     public DateTimeOffset CreatedOn { get; set; }
///     public DateTimeOffset ModifiedOn { get; set; }
/// }
/// </code>
/// </example>
public interface ITimestampedEntity
{
    /// <summary>
    /// Gets or sets the UTC timestamp when this entity was created.
    /// </summary>
    /// <remarks>
    /// Automatically populated by ImagileDbContext on first SaveChanges for new entities.
    /// Should not be modified after initial creation.
    /// </remarks>
    DateTimeOffset CreatedOn { get; set; }

    /// <summary>
    /// Gets or sets the UTC timestamp when this entity was last modified.
    /// </summary>
    /// <remarks>
    /// Automatically updated by ImagileDbContext on every SaveChanges where the entity has changes.
    /// Initially set to the same value as CreatedOn.
    /// </remarks>
    DateTimeOffset ModifiedOn { get; set; }
}
```

Create the Interfaces directory in the EF Core package if it doesn't exist.
  </action>
  <verify>dotnet build src/Imagile.Framework.EntityFrameworkCore/Imagile.Framework.EntityFrameworkCore.csproj --no-restore</verify>
  <done>ITimestampedEntity interface exists with CreatedOn and ModifiedOn DateTimeOffset properties</done>
</task>

<task type="auto">
  <name>Task 3: Create IAuditableEntity interface</name>
  <files>src/Imagile.Framework.EntityFrameworkCore/Interfaces/IAuditableEntity.cs</files>
  <action>
Create the full audit interface that extends ITimestampedEntity with user tracking and soft delete.

Implementation:
```csharp
namespace Imagile.Framework.EntityFrameworkCore.Interfaces;

/// <summary>
/// Marks an entity for full audit tracking including user context and soft delete support.
/// </summary>
/// <typeparam name="TUserKey">The type of the user identifier (e.g., int, Guid, string)</typeparam>
/// <remarks>
/// <para>
/// Extends ITimestampedEntity to add user tracking (CreatedBy, ModifiedBy) and soft delete
/// (IsDeleted, DeletedOn, DeletedBy). Use this interface when you need to know WHO made changes,
/// not just WHEN they occurred.
/// </para>
/// <para>
/// Soft delete support is built-in: setting IsDeleted = true will populate DeletedOn and DeletedBy
/// automatically. Use global query filters to exclude soft-deleted entities from normal queries.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// public class Customer : IAuditableEntity&lt;int&gt;
/// {
///     public int Id { get; set; }
///     public string Name { get; set; } = string.Empty;
///
///     // ITimestampedEntity
///     public DateTimeOffset CreatedOn { get; set; }
///     public DateTimeOffset ModifiedOn { get; set; }
///
///     // IAuditableEntity - user tracking
///     public int? CreatedBy { get; set; }
///     public int? ModifiedBy { get; set; }
///
///     // IAuditableEntity - soft delete
///     public bool IsDeleted { get; set; }
///     public DateTimeOffset? DeletedOn { get; set; }
///     public int? DeletedBy { get; set; }
/// }
/// </code>
/// </example>
public interface IAuditableEntity<TUserKey> : ITimestampedEntity
{
    /// <summary>
    /// Gets or sets the user identifier who created this entity.
    /// </summary>
    /// <remarks>
    /// Automatically populated from IAuditContextProvider.UserId on insert.
    /// Nullable to support system-generated records without user context.
    /// </remarks>
    TUserKey? CreatedBy { get; set; }

    /// <summary>
    /// Gets or sets the user identifier who last modified this entity.
    /// </summary>
    /// <remarks>
    /// Automatically updated from IAuditContextProvider.UserId on every SaveChanges.
    /// </remarks>
    TUserKey? ModifiedBy { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether this entity has been soft-deleted.
    /// </summary>
    /// <remarks>
    /// When set to true, DeletedOn and DeletedBy are automatically populated.
    /// Use global query filters to exclude soft-deleted entities from normal queries.
    /// </remarks>
    bool IsDeleted { get; set; }

    /// <summary>
    /// Gets or sets the UTC timestamp when this entity was soft-deleted.
    /// </summary>
    /// <remarks>
    /// Automatically populated when IsDeleted changes from false to true.
    /// Cleared when entity is restored (IsDeleted set back to false).
    /// </remarks>
    DateTimeOffset? DeletedOn { get; set; }

    /// <summary>
    /// Gets or sets the user identifier who soft-deleted this entity.
    /// </summary>
    /// <remarks>
    /// Automatically populated from IAuditContextProvider.UserId when soft-deleting.
    /// Cleared when entity is restored.
    /// </remarks>
    TUserKey? DeletedBy { get; set; }
}
```
  </action>
  <verify>dotnet build src/Imagile.Framework.EntityFrameworkCore/Imagile.Framework.EntityFrameworkCore.csproj --no-restore</verify>
  <done>IAuditableEntity interface exists inheriting from ITimestampedEntity with user tracking (CreatedBy, ModifiedBy) and soft delete (IsDeleted, DeletedOn, DeletedBy) properties</done>
</task>

<task type="auto">
  <name>Task 4: Create IEntityChangeAuditable interface</name>
  <files>src/Imagile.Framework.EntityFrameworkCore/Interfaces/IEntityChangeAuditable.cs</files>
  <action>
Create the property-level change tracking interface that extends IAuditableEntity.

Based on Arcoro.One pattern, this interface adds properties needed for EntityChange tracking.

Implementation:
```csharp
namespace Imagile.Framework.EntityFrameworkCore.Interfaces;

/// <summary>
/// Marks an entity for property-level change tracking. Records old and new values for audited properties.
/// </summary>
/// <typeparam name="TUserKey">The type of the user identifier (e.g., int, Guid, string)</typeparam>
/// <remarks>
/// <para>
/// Extends IAuditableEntity to enable detailed change history. When an entity implementing this interface
/// is modified, the system creates EntityChange and EntityChangeProperty records capturing exactly
/// what changed, the old value, and the new value.
/// </para>
/// <para>
/// Only properties marked with [Auditable] attribute are tracked. Use this interface when you need
/// detailed audit trails for compliance, debugging, or undo functionality.
/// </para>
/// <para>
/// The ItemId property should return the entity's primary key. For entities with auto-generated keys,
/// this may be null/0 until after SaveChanges completes.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// public class Invoice : IEntityChangeAuditable&lt;int&gt;
/// {
///     public int Id { get; set; }
///
///     [Auditable]
///     public decimal Amount { get; set; }
///
///     [Auditable]
///     public string Status { get; set; } = string.Empty;
///
///     // IEntityChangeAuditable implementation
///     public int? ItemId => Id == 0 ? null : Id;
///     public string? ParentEntityName => null;
///     public int? ParentItemId => null;
///     public string? EntityChangeDescription => $"Invoice #{Id}";
///
///     // IAuditableEntity properties...
/// }
/// </code>
/// </example>
public interface IEntityChangeAuditable<TUserKey> : IAuditableEntity<TUserKey>
{
    /// <summary>
    /// Gets the primary key value for EntityChange tracking.
    /// </summary>
    /// <remarks>
    /// Returns the entity's primary key, or null if not yet persisted (auto-generated key).
    /// The audit system handles temporary values and populates the EntityChange.ItemId
    /// after SaveChanges completes.
    /// </remarks>
    int? ItemId { get; }

    /// <summary>
    /// Gets the parent entity type name for hierarchical change tracking.
    /// </summary>
    /// <remarks>
    /// Use this to link child entity changes to their parent. For example, an OrderLine
    /// might return "Order" to group its changes with the parent Order's changes.
    /// Return null for root entities without a parent relationship.
    /// </remarks>
    string? ParentEntityName { get; }

    /// <summary>
    /// Gets the parent entity's primary key for hierarchical change tracking.
    /// </summary>
    /// <remarks>
    /// The foreign key value linking to the parent entity. Used together with
    /// ParentEntityName to create a hierarchical audit trail.
    /// </remarks>
    int? ParentItemId { get; }

    /// <summary>
    /// Gets a human-readable description for the EntityChange record.
    /// </summary>
    /// <remarks>
    /// Provides context in audit logs. For example: "Invoice #1234" or "Customer: Acme Corp".
    /// Return null to use the default (entity type name + primary key).
    /// </remarks>
    string? EntityChangeDescription { get; }
}
```
  </action>
  <verify>dotnet build src/Imagile.Framework.EntityFrameworkCore/Imagile.Framework.EntityFrameworkCore.csproj --no-restore</verify>
  <done>IEntityChangeAuditable interface exists inheriting from IAuditableEntity with ItemId, ParentEntityName, ParentItemId, and EntityChangeDescription properties</done>
</task>

<task type="auto">
  <name>Task 5: Create ITenantEntity interface</name>
  <files>src/Imagile.Framework.EntityFrameworkCore/Interfaces/ITenantEntity.cs</files>
  <action>
Create the tenant entity interface as a separate concern from auditing.

This interface is independent of the audit hierarchy - entities can implement both IAuditableEntity AND ITenantEntity.

Implementation:
```csharp
namespace Imagile.Framework.EntityFrameworkCore.Interfaces;

/// <summary>
/// Marks an entity as tenant-scoped for multi-tenant data isolation.
/// </summary>
/// <typeparam name="TTenantKey">The type of the tenant identifier (e.g., int, Guid, string)</typeparam>
/// <remarks>
/// <para>
/// Entities implementing this interface are automatically filtered by tenant using global query filters.
/// The TenantId is populated from IAuditContextProvider.TenantId on insert.
/// </para>
/// <para>
/// This interface is separate from the audit interfaces - an entity can be tenant-scoped without
/// being audited, or fully audited without being tenant-scoped. Implement both interfaces when needed.
/// </para>
/// <para>
/// <strong>Security Note:</strong> Using IgnoreQueryFilters() disables ALL global filters including
/// tenant isolation. In EF Core 10.0, use named filters to disable soft delete while keeping
/// tenant filtering active.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// // Tenant-scoped and audited
/// public class Project : IAuditableEntity&lt;int&gt;, ITenantEntity&lt;int&gt;
/// {
///     public int Id { get; set; }
///     public string Name { get; set; } = string.Empty;
///
///     // ITenantEntity
///     public int TenantId { get; set; }
///
///     // IAuditableEntity properties...
/// }
///
/// // Tenant-scoped only (no audit)
/// public class TenantSettings : ITenantEntity&lt;int&gt;
/// {
///     public int Id { get; set; }
///     public int TenantId { get; set; }
///     public string Settings { get; set; } = "{}";
/// }
/// </code>
/// </example>
public interface ITenantEntity<TTenantKey>
{
    /// <summary>
    /// Gets or sets the tenant identifier this entity belongs to.
    /// </summary>
    /// <remarks>
    /// Automatically populated from IAuditContextProvider.TenantId on insert.
    /// Should not be modified after initial creation to maintain data isolation.
    /// Global query filters automatically restrict queries to the current tenant.
    /// </remarks>
    TTenantKey TenantId { get; set; }
}
```
  </action>
  <verify>dotnet build src/Imagile.Framework.EntityFrameworkCore/Imagile.Framework.EntityFrameworkCore.csproj --no-restore</verify>
  <done>ITenantEntity interface exists with TenantId property, separate from audit interface hierarchy</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `dotnet build Imagile.Framework.sln --no-restore` succeeds with no errors
- [ ] IAuditContextProvider exists in Core package with UserId, TenantId, CorrelationId, IsAuthenticated
- [ ] ITimestampedEntity exists with CreatedOn, ModifiedOn
- [ ] IAuditableEntity inherits from ITimestampedEntity, adds user tracking and soft delete
- [ ] IEntityChangeAuditable inherits from IAuditableEntity, adds change tracking properties
- [ ] ITenantEntity is independent with TenantId property
- [ ] All interfaces have comprehensive XML documentation
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Interface hierarchy correctly established (ITimestampedEntity -> IAuditableEntity -> IEntityChangeAuditable)
- ITenantEntity independent of audit hierarchy
- IAuditContextProvider in Core package (zero dependencies)
- All interfaces use generic type parameters for flexibility
</success_criteria>

<output>
After completion, create `.planning/phases/03-ef-core-package/03-01-SUMMARY.md`
</output>

---
phase: 06-azure-storage-abstractions
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/Imagile.Framework.Storage/Extensions/StorageClientExtensions.cs
  - src/Imagile.Framework.Storage/Initialization/StorageResourceScanner.cs
  - src/Imagile.Framework.Storage/Initialization/StorageResources.cs
autonomous: true

must_haves:
  truths:
    - "Developer can call GetQueueClient<T>() to get type-safe queue client"
    - "Developer can call GetBlobContainerClient<T>() to get type-safe container client"
    - "Framework can scan assemblies for IQueueMessage and IBlobContainer implementations"
    - "Scanner extracts queue names and container names from static abstract properties"
  artifacts:
    - path: "src/Imagile.Framework.Storage/Extensions/StorageClientExtensions.cs"
      provides: "Type-safe extension methods for Azure Storage clients"
      exports: ["GetQueueClient<T>", "GetBlobContainerClient<T>"]
    - path: "src/Imagile.Framework.Storage/Initialization/StorageResourceScanner.cs"
      provides: "Reflection-based type discovery for storage interfaces"
      exports: ["ScanForResources", "GetQueueName", "GetContainerName"]
    - path: "src/Imagile.Framework.Storage/Initialization/StorageResources.cs"
      provides: "Record holding discovered queue and container types"
      contains: "record StorageResources"
  key_links:
    - from: "StorageClientExtensions.cs"
      to: "IQueueMessage/IBlobContainer"
      via: "generic constraint T : IQueueMessage"
      pattern: "where T : IQueueMessage"
    - from: "StorageResourceScanner.cs"
      to: "StorageAccountAttribute"
      via: "GetCustomAttribute lookup"
      pattern: "GetCustomAttribute<StorageAccountAttribute>"
---

<objective>
Create type-safe extension methods for Azure Storage clients and reflection-based assembly scanning.

Purpose: Enable developers to retrieve queue/container clients using generic type parameters (GetQueueClient<T>()) instead of hardcoded strings. The scanner discovers all IQueueMessage/IBlobContainer implementations for automatic initialization.

Output: Extension methods for QueueServiceClient/BlobServiceClient and StorageResourceScanner for type discovery.
</objective>

<execution_context>
@C:\Users\kolat\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\kolat\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-azure-storage-abstractions/06-CONTEXT.md
@.planning/phases/06-azure-storage-abstractions/06-RESEARCH.md
@.planning/phases/06-azure-storage-abstractions/06-01-SUMMARY.md
@src/Imagile.Framework.Storage/Interfaces/IQueueMessage.cs
@src/Imagile.Framework.Storage/Interfaces/IBlobContainer.cs
@src/Imagile.Framework.Storage/Attributes/StorageAccountAttribute.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create type-safe storage client extension methods</name>
  <files>
    src/Imagile.Framework.Storage/Extensions/StorageClientExtensions.cs
  </files>
  <action>
Create extension methods for QueueServiceClient and BlobServiceClient using imagile-app pattern:

1. Create `src/Imagile.Framework.Storage/Extensions/StorageClientExtensions.cs`:
```csharp
using Azure.Storage.Blobs;
using Azure.Storage.Queues;
using Imagile.Framework.Storage.Interfaces;

namespace Imagile.Framework.Storage.Extensions;

/// <summary>
/// Provides type-safe extension methods for Azure Storage service clients.
/// </summary>
/// <remarks>
/// These extensions leverage the static abstract <see cref="IQueueMessage.DefaultQueueName"/>
/// and <see cref="IBlobContainer.DefaultContainerName"/> properties to enable type-safe
/// client retrieval without hardcoded queue/container names.
/// </remarks>
public static class StorageClientExtensions
{
    /// <summary>
    /// Gets a queue client for the specified message type using its default queue name.
    /// </summary>
    /// <typeparam name="T">
    /// The queue message type implementing <see cref="IQueueMessage"/>.
    /// </typeparam>
    /// <param name="client">The queue service client.</param>
    /// <returns>
    /// A <see cref="QueueClient"/> configured for the queue associated with type <typeparamref name="T"/>.
    /// </returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown when <paramref name="client"/> is null.
    /// </exception>
    /// <example>
    /// <code>
    /// public class TenantVerificationMessage : IQueueMessage
    /// {
    ///     public static string DefaultQueueName => "tenant-verification";
    ///     public int TenantId { get; set; }
    /// }
    ///
    /// // Type-safe queue access
    /// var queue = queueServiceClient.GetQueueClient&lt;TenantVerificationMessage&gt;();
    /// await queue.SendMessageAsync(JsonSerializer.Serialize(message));
    /// </code>
    /// </example>
    public static QueueClient GetQueueClient<T>(this QueueServiceClient client)
        where T : IQueueMessage
    {
        ArgumentNullException.ThrowIfNull(client);
        return client.GetQueueClient(T.DefaultQueueName);
    }

    /// <summary>
    /// Gets a blob container client for the specified container type using its default container name.
    /// </summary>
    /// <typeparam name="T">
    /// The blob container type implementing <see cref="IBlobContainer"/>.
    /// </typeparam>
    /// <param name="client">The blob service client.</param>
    /// <returns>
    /// A <see cref="BlobContainerClient"/> configured for the container associated with type <typeparamref name="T"/>.
    /// </returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown when <paramref name="client"/> is null.
    /// </exception>
    /// <example>
    /// <code>
    /// public class TenantDocumentContainer : IBlobContainer
    /// {
    ///     public static string DefaultContainerName => "tenant-documents";
    /// }
    ///
    /// // Type-safe container access
    /// var container = blobServiceClient.GetBlobContainerClient&lt;TenantDocumentContainer&gt;();
    /// var blob = container.GetBlobClient($"tenants/{tenantId}/document.pdf");
    /// await blob.UploadAsync(stream);
    /// </code>
    /// </example>
    public static BlobContainerClient GetBlobContainerClient<T>(this BlobServiceClient client)
        where T : IBlobContainer
    {
        ArgumentNullException.ThrowIfNull(client);
        return client.GetBlobContainerClient(T.DefaultContainerName);
    }
}
```

2. Verify build:
```bash
dotnet build src/Imagile.Framework.Storage
```
  </action>
  <verify>
`dotnet build src/Imagile.Framework.Storage` succeeds.
Extension methods use generic constraints `where T : IQueueMessage` and `where T : IBlobContainer`.
  </verify>
  <done>
GetQueueClient<T>() extension returns QueueClient using T.DefaultQueueName.
GetBlobContainerClient<T>() extension returns BlobContainerClient using T.DefaultContainerName.
Both methods have null validation and comprehensive XML documentation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create StorageResources record and StorageResourceScanner</name>
  <files>
    src/Imagile.Framework.Storage/Initialization/StorageResources.cs
    src/Imagile.Framework.Storage/Initialization/StorageResourceScanner.cs
  </files>
  <action>
Create reflection-based scanner for discovering storage interface implementations:

1. Create `src/Imagile.Framework.Storage/Initialization/StorageResources.cs`:
```csharp
namespace Imagile.Framework.Storage.Initialization;

/// <summary>
/// Contains discovered queue message and blob container types from assembly scanning.
/// </summary>
/// <param name="QueueTypes">
/// Types implementing <see cref="Interfaces.IQueueMessage"/> discovered during scanning.
/// </param>
/// <param name="ContainerTypes">
/// Types implementing <see cref="Interfaces.IBlobContainer"/> discovered during scanning.
/// </param>
public sealed record StorageResources(
    IReadOnlyList<Type> QueueTypes,
    IReadOnlyList<Type> ContainerTypes)
{
    /// <summary>
    /// Gets the total count of discovered storage resources.
    /// </summary>
    public int TotalCount => QueueTypes.Count + ContainerTypes.Count;

    /// <summary>
    /// Gets a value indicating whether any storage resources were discovered.
    /// </summary>
    public bool HasResources => TotalCount > 0;

    /// <summary>
    /// Creates an empty <see cref="StorageResources"/> instance.
    /// </summary>
    public static StorageResources Empty { get; } = new([], []);
}
```

2. Create `src/Imagile.Framework.Storage/Initialization/StorageResourceScanner.cs`:
```csharp
using System.Reflection;
using Imagile.Framework.Storage.Attributes;
using Imagile.Framework.Storage.Interfaces;

namespace Imagile.Framework.Storage.Initialization;

/// <summary>
/// Scans assemblies for types implementing Azure Storage interfaces.
/// </summary>
/// <remarks>
/// <para>
/// The scanner discovers all concrete classes implementing <see cref="IQueueMessage"/>
/// and <see cref="IBlobContainer"/> in the specified assemblies. These types are then
/// used for automatic queue/container initialization.
/// </para>
/// <para>
/// For performance, pass only assemblies that contain storage types. Do not use
/// <c>AppDomain.CurrentDomain.GetAssemblies()</c> as it includes all loaded assemblies.
/// </para>
/// </remarks>
public static class StorageResourceScanner
{
    /// <summary>
    /// Scans assemblies for types implementing storage interfaces.
    /// </summary>
    /// <param name="assemblies">
    /// Assemblies to scan. If empty, scans the calling assembly.
    /// </param>
    /// <returns>
    /// A <see cref="StorageResources"/> instance containing discovered queue and container types.
    /// </returns>
    /// <example>
    /// <code>
    /// // Scan specific assemblies
    /// var resources = StorageResourceScanner.ScanForResources(
    ///     typeof(MyQueueMessage).Assembly,
    ///     typeof(MyBlobContainer).Assembly);
    ///
    /// Console.WriteLine($"Found {resources.QueueTypes.Count} queues");
    /// Console.WriteLine($"Found {resources.ContainerTypes.Count} containers");
    /// </code>
    /// </example>
    public static StorageResources ScanForResources(params Assembly[] assemblies)
    {
        if (assemblies.Length == 0)
        {
            assemblies = [Assembly.GetCallingAssembly()];
        }

        var queueTypes = assemblies
            .SelectMany(a => a.GetTypes())
            .Where(t => t.IsClass && !t.IsAbstract && typeof(IQueueMessage).IsAssignableFrom(t))
            .ToList();

        var containerTypes = assemblies
            .SelectMany(a => a.GetTypes())
            .Where(t => t.IsClass && !t.IsAbstract && typeof(IBlobContainer).IsAssignableFrom(t))
            .ToList();

        return new StorageResources(queueTypes, containerTypes);
    }

    /// <summary>
    /// Gets the queue name from a type implementing <see cref="IQueueMessage"/>.
    /// </summary>
    /// <param name="queueMessageType">
    /// The type implementing <see cref="IQueueMessage"/>.
    /// </param>
    /// <returns>The queue name from the type's <c>DefaultQueueName</c> property.</returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown when <paramref name="queueMessageType"/> is null.
    /// </exception>
    /// <exception cref="InvalidOperationException">
    /// Thrown when the type does not have a <c>DefaultQueueName</c> static property.
    /// </exception>
    public static string GetQueueName(Type queueMessageType)
    {
        ArgumentNullException.ThrowIfNull(queueMessageType);

        var property = queueMessageType.GetProperty(
            nameof(IQueueMessage.DefaultQueueName),
            BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy);

        return property?.GetValue(null) as string
            ?? throw new InvalidOperationException(
                $"Type {queueMessageType.FullName} does not have a static DefaultQueueName property.");
    }

    /// <summary>
    /// Gets the container name from a type implementing <see cref="IBlobContainer"/>.
    /// </summary>
    /// <param name="blobContainerType">
    /// The type implementing <see cref="IBlobContainer"/>.
    /// </param>
    /// <returns>The container name from the type's <c>DefaultContainerName</c> property.</returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown when <paramref name="blobContainerType"/> is null.
    /// </exception>
    /// <exception cref="InvalidOperationException">
    /// Thrown when the type does not have a <c>DefaultContainerName</c> static property.
    /// </exception>
    public static string GetContainerName(Type blobContainerType)
    {
        ArgumentNullException.ThrowIfNull(blobContainerType);

        var property = blobContainerType.GetProperty(
            nameof(IBlobContainer.DefaultContainerName),
            BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy);

        return property?.GetValue(null) as string
            ?? throw new InvalidOperationException(
                $"Type {blobContainerType.FullName} does not have a static DefaultContainerName property.");
    }

    /// <summary>
    /// Gets the storage account name from a type's <see cref="StorageAccountAttribute"/>.
    /// </summary>
    /// <param name="type">The type to check for the attribute.</param>
    /// <returns>
    /// The storage account name if the attribute is present; otherwise, <c>null</c> for the default account.
    /// </returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown when <paramref name="type"/> is null.
    /// </exception>
    public static string? GetStorageAccountName(Type type)
    {
        ArgumentNullException.ThrowIfNull(type);
        return type.GetCustomAttribute<StorageAccountAttribute>()?.Name;
    }
}
```

3. Verify build:
```bash
dotnet build src/Imagile.Framework.Storage
```
  </action>
  <verify>
`dotnet build src/Imagile.Framework.Storage` succeeds with 0 errors, 0 warnings.
StorageResources record has QueueTypes and ContainerTypes properties.
StorageResourceScanner has ScanForResources, GetQueueName, GetContainerName, and GetStorageAccountName methods.
  </verify>
  <done>
StorageResourceScanner.ScanForResources() discovers IQueueMessage and IBlobContainer implementations.
GetQueueName() extracts DefaultQueueName via reflection.
GetContainerName() extracts DefaultContainerName via reflection.
GetStorageAccountName() extracts StorageAccountAttribute value.
All methods have null validation and comprehensive XML documentation.
  </done>
</task>

</tasks>

<verification>
After all tasks:

1. Solution builds: `dotnet build Imagile.Framework.sln` succeeds
2. Extension methods compile with generic constraints
3. Scanner methods use reflection correctly for static property access
4. GetStorageAccountName returns null for types without attribute
</verification>

<success_criteria>
- [ ] GetQueueClient<T>() compiles with `where T : IQueueMessage` constraint
- [ ] GetBlobContainerClient<T>() compiles with `where T : IBlobContainer` constraint
- [ ] StorageResourceScanner.ScanForResources() returns StorageResources record
- [ ] GetQueueName() throws InvalidOperationException for invalid types
- [ ] GetContainerName() throws InvalidOperationException for invalid types
- [ ] GetStorageAccountName() returns null for types without StorageAccountAttribute
- [ ] Solution builds with 0 errors, 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/06-azure-storage-abstractions/06-02-SUMMARY.md`
</output>

---
phase: 06-azure-storage-abstractions
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - src/Imagile.Framework.Storage/DependencyInjection/StorageBuilder.cs
  - src/Imagile.Framework.Storage/DependencyInjection/StorageOptions.cs
  - src/Imagile.Framework.Storage/Extensions/ServiceCollectionExtensions.cs
  - src/Imagile.Framework.Storage/Extensions/StorageInitializationExtensions.cs
  - src/Imagile.Framework.Storage/Initialization/InitializationResult.cs
autonomous: true

must_haves:
  truths:
    - "Developer can call AddStorageAbstractions() to register Azure Storage clients"
    - "Developer can configure multiple storage accounts with credential or connection string"
    - "Developer can call InitializeStorageResourcesAsync() to create queues and containers"
    - "Initialization creates resources based on scanned IQueueMessage/IBlobContainer types"
  artifacts:
    - path: "src/Imagile.Framework.Storage/Extensions/ServiceCollectionExtensions.cs"
      provides: "AddStorageAbstractions() fluent API entry point"
      exports: ["AddStorageAbstractions"]
    - path: "src/Imagile.Framework.Storage/DependencyInjection/StorageBuilder.cs"
      provides: "Fluent builder for storage configuration"
      exports: ["AddStorageAccount", "ScanAssemblies"]
    - path: "src/Imagile.Framework.Storage/Extensions/StorageInitializationExtensions.cs"
      provides: "IServiceProvider extension for resource initialization"
      exports: ["InitializeStorageResourcesAsync"]
  key_links:
    - from: "ServiceCollectionExtensions.cs"
      to: "StorageBuilder"
      via: "returns builder for fluent chaining"
      pattern: "return new StorageBuilder"
    - from: "StorageBuilder.cs"
      to: "Microsoft.Extensions.Azure"
      via: "AddAzureClients registration"
      pattern: "AddAzureClients"
    - from: "StorageInitializationExtensions.cs"
      to: "StorageResourceScanner"
      via: "uses scanned resources for initialization"
      pattern: "StorageResourceScanner\\.GetQueueName"
---

<objective>
Create fluent API for DI registration and initialization helper for automatic queue/container creation.

Purpose: Enable developers to configure Azure Storage clients with a clean fluent API pattern (matching Phase 5's configuration pattern). The initialization helper uses scanned types to automatically create queues and blob containers at startup.

Output: AddStorageAbstractions() builder API and InitializeStorageResourcesAsync() extension.
</objective>

<execution_context>
@C:\Users\kolat\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\kolat\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-azure-storage-abstractions/06-CONTEXT.md
@.planning/phases/06-azure-storage-abstractions/06-RESEARCH.md
@.planning/phases/06-azure-storage-abstractions/06-01-SUMMARY.md
@.planning/phases/06-azure-storage-abstractions/06-02-SUMMARY.md
@src/Imagile.Framework.Storage/Initialization/StorageResourceScanner.cs
@src/Imagile.Framework.Storage/Initialization/StorageResources.cs
@src/Imagile.Framework.Storage/Attributes/StorageAccountAttribute.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StorageOptions and StorageBuilder for fluent configuration</name>
  <files>
    src/Imagile.Framework.Storage/DependencyInjection/StorageOptions.cs
    src/Imagile.Framework.Storage/DependencyInjection/StorageBuilder.cs
  </files>
  <action>
Create fluent API builder pattern similar to Phase 5's configuration pattern:

1. Create `src/Imagile.Framework.Storage/DependencyInjection/StorageOptions.cs`:
```csharp
using System.Reflection;
using Azure.Core;

namespace Imagile.Framework.Storage.DependencyInjection;

/// <summary>
/// Configuration options for Azure Storage abstractions.
/// </summary>
public sealed class StorageOptions
{
    /// <summary>
    /// Gets the registered storage accounts.
    /// </summary>
    internal Dictionary<string, StorageAccountOptions> Accounts { get; } = new();

    /// <summary>
    /// Gets the assemblies to scan for storage interface implementations.
    /// </summary>
    internal List<Assembly> AssembliesToScan { get; } = [];

    /// <summary>
    /// Gets or sets the global retry options applied to all storage clients.
    /// </summary>
    public RetryOptions? RetryOptions { get; set; }
}

/// <summary>
/// Configuration for a single storage account.
/// </summary>
public sealed class StorageAccountOptions
{
    /// <summary>
    /// Gets or sets the storage account connection string.
    /// </summary>
    /// <remarks>
    /// Either <see cref="ConnectionString"/> or <see cref="ServiceUri"/> with <see cref="Credential"/>
    /// must be provided. If both are provided, <see cref="Credential"/> takes precedence.
    /// </remarks>
    public string? ConnectionString { get; set; }

    /// <summary>
    /// Gets or sets the storage account service URI for token-based authentication.
    /// </summary>
    /// <remarks>
    /// Use this with <see cref="Credential"/> for identity-based authentication.
    /// Format: https://{account}.blob.core.windows.net or https://{account}.queue.core.windows.net
    /// </remarks>
    public Uri? ServiceUri { get; set; }

    /// <summary>
    /// Gets or sets the token credential for authentication.
    /// </summary>
    /// <remarks>
    /// When provided, takes precedence over <see cref="ConnectionString"/> for authentication.
    /// Use <c>AppTokenCredential</c> from Imagile.Framework.Configuration for environment-aware authentication.
    /// </remarks>
    public TokenCredential? Credential { get; set; }
}
```

2. Create `src/Imagile.Framework.Storage/DependencyInjection/StorageBuilder.cs`:
```csharp
using System.Reflection;
using Azure.Core;
using Azure.Storage.Blobs;
using Azure.Storage.Queues;
using Microsoft.Extensions.Azure;
using Microsoft.Extensions.DependencyInjection;
using Imagile.Framework.Storage.Initialization;

namespace Imagile.Framework.Storage.DependencyInjection;

/// <summary>
/// Builder for configuring Azure Storage abstractions.
/// </summary>
/// <remarks>
/// Use this builder to configure storage accounts, credentials, and assembly scanning
/// for automatic queue and container discovery.
/// </remarks>
public sealed class StorageBuilder
{
    private readonly IServiceCollection _services;
    private readonly StorageOptions _options = new();

    internal StorageBuilder(IServiceCollection services)
    {
        _services = services;
    }

    /// <summary>
    /// Adds the default (unnamed) storage account using a connection string.
    /// </summary>
    /// <param name="connectionString">The Azure Storage connection string.</param>
    /// <returns>The builder for method chaining.</returns>
    /// <exception cref="ArgumentException">
    /// Thrown when <paramref name="connectionString"/> is null or whitespace.
    /// </exception>
    public StorageBuilder AddStorageAccount(string connectionString)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(connectionString);
        return AddStorageAccount("Default", connectionString, credential: null);
    }

    /// <summary>
    /// Adds the default (unnamed) storage account using a service URI and credential.
    /// </summary>
    /// <param name="serviceUri">The storage account service URI.</param>
    /// <param name="credential">The token credential for authentication.</param>
    /// <returns>The builder for method chaining.</returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown when <paramref name="serviceUri"/> or <paramref name="credential"/> is null.
    /// </exception>
    public StorageBuilder AddStorageAccount(Uri serviceUri, TokenCredential credential)
    {
        ArgumentNullException.ThrowIfNull(serviceUri);
        ArgumentNullException.ThrowIfNull(credential);
        return AddStorageAccount("Default", serviceUri, credential);
    }

    /// <summary>
    /// Adds a named storage account using a connection string.
    /// </summary>
    /// <param name="name">The storage account name for DI resolution.</param>
    /// <param name="connectionString">The Azure Storage connection string.</param>
    /// <returns>The builder for method chaining.</returns>
    /// <exception cref="ArgumentException">
    /// Thrown when <paramref name="name"/> or <paramref name="connectionString"/> is null or whitespace.
    /// </exception>
    public StorageBuilder AddStorageAccount(string name, string connectionString)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(name);
        ArgumentException.ThrowIfNullOrWhiteSpace(connectionString);
        return AddStorageAccount(name, connectionString, credential: null);
    }

    /// <summary>
    /// Adds a named storage account using a connection string and optional credential.
    /// </summary>
    /// <param name="name">The storage account name for DI resolution.</param>
    /// <param name="connectionString">The Azure Storage connection string.</param>
    /// <param name="credential">Optional token credential (takes precedence over connection string auth).</param>
    /// <returns>The builder for method chaining.</returns>
    public StorageBuilder AddStorageAccount(string name, string connectionString, TokenCredential? credential)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(name);
        ArgumentException.ThrowIfNullOrWhiteSpace(connectionString);

        _options.Accounts[name] = new StorageAccountOptions
        {
            ConnectionString = connectionString,
            Credential = credential
        };

        return this;
    }

    /// <summary>
    /// Adds a named storage account using a service URI and credential.
    /// </summary>
    /// <param name="name">The storage account name for DI resolution.</param>
    /// <param name="serviceUri">The storage account service URI.</param>
    /// <param name="credential">The token credential for authentication.</param>
    /// <returns>The builder for method chaining.</returns>
    public StorageBuilder AddStorageAccount(string name, Uri serviceUri, TokenCredential credential)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(name);
        ArgumentNullException.ThrowIfNull(serviceUri);
        ArgumentNullException.ThrowIfNull(credential);

        _options.Accounts[name] = new StorageAccountOptions
        {
            ServiceUri = serviceUri,
            Credential = credential
        };

        return this;
    }

    /// <summary>
    /// Specifies assemblies to scan for <see cref="Interfaces.IQueueMessage"/> and
    /// <see cref="Interfaces.IBlobContainer"/> implementations.
    /// </summary>
    /// <param name="assemblies">The assemblies to scan.</param>
    /// <returns>The builder for method chaining.</returns>
    public StorageBuilder ScanAssemblies(params Assembly[] assemblies)
    {
        _options.AssembliesToScan.AddRange(assemblies);
        return this;
    }

    /// <summary>
    /// Configures global retry options for all storage clients.
    /// </summary>
    /// <param name="retryOptions">The retry options to apply.</param>
    /// <returns>The builder for method chaining.</returns>
    public StorageBuilder ConfigureRetry(RetryOptions retryOptions)
    {
        _options.RetryOptions = retryOptions;
        return this;
    }

    /// <summary>
    /// Builds and registers the configured storage services.
    /// </summary>
    internal void Build()
    {
        if (_options.Accounts.Count == 0)
        {
            throw new InvalidOperationException(
                "At least one storage account must be configured. Call AddStorageAccount() before building.");
        }

        // Register scanned resources as singleton
        var resources = _options.AssembliesToScan.Count > 0
            ? StorageResourceScanner.ScanForResources([.. _options.AssembliesToScan])
            : StorageResources.Empty;

        _services.AddSingleton(resources);
        _services.AddSingleton(_options);

        // Register Azure clients using Microsoft.Extensions.Azure
        _services.AddAzureClients(builder =>
        {
            foreach (var (name, accountOptions) in _options.Accounts)
            {
                RegisterStorageAccount(builder, name, accountOptions);
            }

            // Configure global retry if specified
            if (_options.RetryOptions != null)
            {
                builder.ConfigureDefaults(options =>
                {
                    options.Retry.Delay = _options.RetryOptions.Delay;
                    options.Retry.MaxRetries = _options.RetryOptions.MaxRetries;
                    options.Retry.Mode = _options.RetryOptions.Mode;
                    options.Retry.MaxDelay = _options.RetryOptions.MaxDelay;
                    options.Retry.NetworkTimeout = _options.RetryOptions.NetworkTimeout;
                });
            }
        });
    }

    private static void RegisterStorageAccount(
        AzureClientFactoryBuilder builder,
        string name,
        StorageAccountOptions options)
    {
        // Queue client registration
        if (options.ServiceUri != null && options.Credential != null)
        {
            // URI-based authentication
            var queueUri = BuildServiceUri(options.ServiceUri, "queue");
            var blobUri = BuildServiceUri(options.ServiceUri, "blob");

            builder.AddQueueServiceClient(queueUri)
                .WithName(name)
                .WithCredential(options.Credential)
                .ConfigureOptions(o => o.MessageEncoding = QueueMessageEncoding.Base64);

            builder.AddBlobServiceClient(blobUri)
                .WithName(name)
                .WithCredential(options.Credential);
        }
        else if (!string.IsNullOrWhiteSpace(options.ConnectionString))
        {
            // Connection string authentication
            builder.AddQueueServiceClient(options.ConnectionString)
                .WithName(name)
                .ConfigureOptions(o => o.MessageEncoding = QueueMessageEncoding.Base64);

            builder.AddBlobServiceClient(options.ConnectionString)
                .WithName(name);

            // Apply credential if provided (takes precedence)
            if (options.Credential != null)
            {
                // Note: When using connection string + credential, the credential
                // will be used for token-based auth instead of the connection string's key
            }
        }
    }

    private static Uri BuildServiceUri(Uri baseUri, string service)
    {
        // If URI already contains the service (queue/blob), use as-is
        if (baseUri.Host.Contains($".{service}.", StringComparison.OrdinalIgnoreCase))
        {
            return baseUri;
        }

        // Otherwise, construct the service-specific URI
        // e.g., https://myaccount.blob.core.windows.net -> https://myaccount.queue.core.windows.net
        var host = baseUri.Host;
        var newHost = host.Replace(".blob.", $".{service}.", StringComparison.OrdinalIgnoreCase)
                         .Replace(".queue.", $".{service}.", StringComparison.OrdinalIgnoreCase);

        if (newHost == host)
        {
            // Assume it's just the account name, construct full URI
            var accountName = host.Split('.')[0];
            return new Uri($"https://{accountName}.{service}.core.windows.net");
        }

        return new UriBuilder(baseUri) { Host = newHost }.Uri;
    }
}
```

3. Verify build:
```bash
dotnet build src/Imagile.Framework.Storage
```
  </action>
  <verify>
`dotnet build src/Imagile.Framework.Storage` succeeds.
StorageBuilder has fluent methods: AddStorageAccount (multiple overloads), ScanAssemblies, ConfigureRetry.
StorageOptions holds accounts and assemblies to scan.
  </verify>
  <done>
StorageBuilder provides fluent API for configuring storage accounts with connection strings or credentials.
ScanAssemblies method accepts Assembly[] for type discovery.
Build() registers Azure clients using Microsoft.Extensions.Azure.
QueueMessageEncoding.Base64 is configured by default.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ServiceCollectionExtensions and InitializationResult</name>
  <files>
    src/Imagile.Framework.Storage/Extensions/ServiceCollectionExtensions.cs
    src/Imagile.Framework.Storage/Initialization/InitializationResult.cs
  </files>
  <action>
Create the entry point extension method and initialization result record:

1. Create `src/Imagile.Framework.Storage/Extensions/ServiceCollectionExtensions.cs`:
```csharp
using Imagile.Framework.Storage.DependencyInjection;
using Microsoft.Extensions.DependencyInjection;

namespace Imagile.Framework.Storage.Extensions;

/// <summary>
/// Extension methods for registering Azure Storage abstractions with dependency injection.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Adds Azure Storage abstractions to the service collection.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <param name="configure">Action to configure storage options.</param>
    /// <returns>The service collection for method chaining.</returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown when <paramref name="services"/> or <paramref name="configure"/> is null.
    /// </exception>
    /// <example>
    /// <code>
    /// services.AddStorageAbstractions(storage =>
    /// {
    ///     // Default storage account
    ///     storage.AddStorageAccount(connectionString);
    ///
    ///     // Or with identity-based auth
    ///     storage.AddStorageAccount(serviceUri, new AppTokenCredential(clientId));
    ///
    ///     // Named storage account for archive
    ///     storage.AddStorageAccount("archive", archiveConnectionString);
    ///
    ///     // Scan for IQueueMessage and IBlobContainer implementations
    ///     storage.ScanAssemblies(typeof(MyQueueMessage).Assembly);
    ///
    ///     // Optional: Configure retry policy
    ///     storage.ConfigureRetry(new RetryOptions
    ///     {
    ///         MaxRetries = 5,
    ///         Delay = TimeSpan.FromSeconds(2),
    ///         Mode = RetryMode.Exponential
    ///     });
    /// });
    /// </code>
    /// </example>
    public static IServiceCollection AddStorageAbstractions(
        this IServiceCollection services,
        Action<StorageBuilder> configure)
    {
        ArgumentNullException.ThrowIfNull(services);
        ArgumentNullException.ThrowIfNull(configure);

        var builder = new StorageBuilder(services);
        configure(builder);
        builder.Build();

        return services;
    }
}
```

2. Create `src/Imagile.Framework.Storage/Initialization/InitializationResult.cs`:
```csharp
namespace Imagile.Framework.Storage.Initialization;

/// <summary>
/// Result of storage resource initialization.
/// </summary>
/// <remarks>
/// Contains lists of queues and containers that were created during initialization.
/// Resources that already existed are not included in these lists.
/// </remarks>
public sealed class InitializationResult
{
    /// <summary>
    /// Gets the queues that were created during initialization.
    /// </summary>
    /// <remarks>
    /// Format: "{accountName}/{queueName}" (e.g., "Default/tenant-verification").
    /// Queues that already existed are not included.
    /// </remarks>
    public List<string> CreatedQueues { get; } = [];

    /// <summary>
    /// Gets the containers that were created during initialization.
    /// </summary>
    /// <remarks>
    /// Format: "{accountName}/{containerName}" (e.g., "archive/audit-logs").
    /// Containers that already existed are not included.
    /// </remarks>
    public List<string> CreatedContainers { get; } = [];

    /// <summary>
    /// Gets the total count of resources created.
    /// </summary>
    public int TotalCreated => CreatedQueues.Count + CreatedContainers.Count;

    /// <summary>
    /// Gets a value indicating whether any resources were created.
    /// </summary>
    public bool HasCreatedResources => TotalCreated > 0;

    /// <summary>
    /// Returns a summary string of the initialization result.
    /// </summary>
    public override string ToString() =>
        $"Created {CreatedQueues.Count} queue(s), {CreatedContainers.Count} container(s)";
}
```

3. Verify build:
```bash
dotnet build src/Imagile.Framework.Storage
```
  </action>
  <verify>
`dotnet build src/Imagile.Framework.Storage` succeeds.
AddStorageAbstractions extension method compiles with Action<StorageBuilder> parameter.
InitializationResult has CreatedQueues and CreatedContainers lists.
  </verify>
  <done>
AddStorageAbstractions() provides fluent entry point for storage configuration.
InitializationResult tracks created queues and containers during initialization.
Both have comprehensive XML documentation with examples.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create StorageInitializationExtensions for automatic resource creation</name>
  <files>
    src/Imagile.Framework.Storage/Extensions/StorageInitializationExtensions.cs
  </files>
  <action>
Create IServiceProvider extension for initializing storage resources:

1. Create `src/Imagile.Framework.Storage/Extensions/StorageInitializationExtensions.cs`:
```csharp
using Azure.Storage.Blobs;
using Azure.Storage.Queues;
using Imagile.Framework.Storage.Initialization;
using Microsoft.Extensions.Azure;
using Microsoft.Extensions.DependencyInjection;

namespace Imagile.Framework.Storage.Extensions;

/// <summary>
/// Extension methods for initializing Azure Storage resources.
/// </summary>
public static class StorageInitializationExtensions
{
    /// <summary>
    /// Initializes all storage resources (queues and containers) discovered by assembly scanning.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This method creates queues and containers if they don't exist, grouping them by storage account
    /// based on the <see cref="Attributes.StorageAccountAttribute"/> on each type.
    /// </para>
    /// <para>
    /// Use this method during application startup for local development to ensure all required
    /// storage resources exist. For production, consider using infrastructure-as-code (Bicep, Terraform)
    /// instead.
    /// </para>
    /// </remarks>
    /// <param name="serviceProvider">The service provider.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>
    /// An <see cref="InitializationResult"/> containing lists of created resources.
    /// </returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown when <paramref name="serviceProvider"/> is null.
    /// </exception>
    /// <exception cref="AggregateException">
    /// Thrown when one or more resources fail to create. Contains all individual exceptions.
    /// </exception>
    /// <example>
    /// <code>
    /// var app = builder.Build();
    ///
    /// // Initialize storage resources at startup (local development)
    /// if (app.Environment.IsDevelopment())
    /// {
    ///     var result = await app.Services.InitializeStorageResourcesAsync();
    ///     app.Logger.LogInformation("Storage init: {Result}", result);
    /// }
    /// </code>
    /// </example>
    public static async Task<InitializationResult> InitializeStorageResourcesAsync(
        this IServiceProvider serviceProvider,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(serviceProvider);

        var resources = serviceProvider.GetRequiredService<StorageResources>();
        var queueFactory = serviceProvider.GetRequiredService<IAzureClientFactory<QueueServiceClient>>();
        var blobFactory = serviceProvider.GetRequiredService<IAzureClientFactory<BlobServiceClient>>();

        var result = new InitializationResult();
        var exceptions = new List<Exception>();

        // Initialize queues grouped by storage account
        var queuesByAccount = resources.QueueTypes
            .GroupBy(t => StorageResourceScanner.GetStorageAccountName(t) ?? "Default");

        foreach (var group in queuesByAccount)
        {
            var queueServiceClient = queueFactory.CreateClient(group.Key);

            foreach (var queueType in group)
            {
                try
                {
                    var queueName = StorageResourceScanner.GetQueueName(queueType);
                    var queueClient = queueServiceClient.GetQueueClient(queueName);
                    var response = await queueClient.CreateIfNotExistsAsync(cancellationToken: cancellationToken);

                    if (response?.Value != null)
                    {
                        result.CreatedQueues.Add($"{group.Key}/{queueName}");
                    }
                }
                catch (Exception ex)
                {
                    exceptions.Add(new InvalidOperationException(
                        $"Failed to create queue for type {queueType.FullName}: {ex.Message}", ex));
                }
            }
        }

        // Initialize containers grouped by storage account
        var containersByAccount = resources.ContainerTypes
            .GroupBy(t => StorageResourceScanner.GetStorageAccountName(t) ?? "Default");

        foreach (var group in containersByAccount)
        {
            var blobServiceClient = blobFactory.CreateClient(group.Key);

            foreach (var containerType in group)
            {
                try
                {
                    var containerName = StorageResourceScanner.GetContainerName(containerType);
                    var containerClient = blobServiceClient.GetBlobContainerClient(containerName);
                    var response = await containerClient.CreateIfNotExistsAsync(cancellationToken: cancellationToken);

                    if (response?.Value != null)
                    {
                        result.CreatedContainers.Add($"{group.Key}/{containerName}");
                    }
                }
                catch (Exception ex)
                {
                    exceptions.Add(new InvalidOperationException(
                        $"Failed to create container for type {containerType.FullName}: {ex.Message}", ex));
                }
            }
        }

        // Fail-fast: throw aggregate exception if any initialization failed
        if (exceptions.Count > 0)
        {
            throw new AggregateException(
                $"Failed to initialize {exceptions.Count} storage resource(s). See inner exceptions for details.",
                exceptions);
        }

        return result;
    }
}
```

2. Verify final build:
```bash
dotnet build src/Imagile.Framework.Storage
dotnet build Imagile.Framework.sln
```
  </action>
  <verify>
`dotnet build Imagile.Framework.sln` succeeds with 0 errors, 0 warnings.
InitializeStorageResourcesAsync uses IAzureClientFactory to get clients.
Method groups resources by StorageAccountAttribute.
Fail-fast behavior throws AggregateException on initialization failures.
  </verify>
  <done>
InitializeStorageResourcesAsync() creates queues and containers for all scanned types.
Resources grouped by storage account based on StorageAccountAttribute.
CreateIfNotExistsAsync used for idempotent initialization.
AggregateException thrown on any failures (fail-fast).
InitializationResult tracks what was created vs what already existed.
  </done>
</task>

</tasks>

<verification>
After all tasks:

1. Full solution builds: `dotnet build Imagile.Framework.sln` succeeds
2. AddStorageAbstractions compiles with fluent builder pattern
3. InitializeStorageResourcesAsync uses Microsoft.Extensions.Azure factories
4. Fail-fast on initialization errors (AggregateException)
5. Base64 encoding configured for queue messages
</verification>

<success_criteria>
- [ ] AddStorageAbstractions() accepts Action<StorageBuilder> for configuration
- [ ] StorageBuilder has AddStorageAccount overloads for connection string and credential
- [ ] ScanAssemblies() accepts Assembly[] for type discovery
- [ ] InitializeStorageResourcesAsync() returns InitializationResult
- [ ] Resources grouped by StorageAccountAttribute during initialization
- [ ] AggregateException thrown when resources fail to create
- [ ] QueueMessageEncoding.Base64 configured by default
- [ ] Solution builds with 0 errors, 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/06-azure-storage-abstractions/06-03-SUMMARY.md`
</output>
